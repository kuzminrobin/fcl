# Meet the Function Call Logger (FCL)
Function Call Logger is a library (a set of crates) that lets the users to instrument their Rust code such that the code during execution logs its own function calls like this:
```
  my_func() {
    f() {}
    // f() repeats 2 time(s).
    m::g(param: 5) {
      { // Loop body start.
        m::h() {}
        m::i() {
          m::j() {}
        } -> -1.23 // m::i().
      } // Loop body end.
      // Loop body repeats 999 time(s).
    } // m::g().
    my_func()::MyStruct::my_method(self: &mut MyStruct { _field: 3 }) {
      my_func()::MyStruct::my_method()::closure{117,38:119,21}(param: 1, &mut MyPoint{x: 2, y: -4}) {} -> -2
This is a sample stderr output.
    } // my_func()::MyStruct::my_method().
  } // my_func().
```
This log has been generated by the following instrumented program fragment.
```rs
use fcl_proc_macros::loggable;

#[loggable]  // The instrumenting macro for `my_func()`.
fn my_func() {
    f(); // Function `my_func()` invokes function `f()` 3 times.
    f();
    f();
    m::g(5); // Then function `g()` from module `m` (see below).

    #[derive(std::fmt::Debug)]
    struct MyStruct { // Structure defined locally in `my_func()`.
        _field: u8
    }
    impl MyStruct {
        fn my_method(&mut self) { // `my_method()` also gets instrumented automatically.
            struct MyPoint {
                x: i32,
                y: i32
            }
            let mut p = MyPoint {
                x: 2,
                y: -4
            };
            // The closure below also gets instrumented automatically.
            let my_closure = |param: u16, &mut MyPoint{ x, y }| { 
                x + y
            };
            let _ = my_closure(1, &mut p);

            eprintln!("This is a sample stderr output.");
        }
    }
    let mut s = MyStruct{ _field: 3 };
    s.my_method(); // Function `my_func()` invokes function `MyStruct::my_method()`.
}

// The instrumenting macro for the whole `mod m` below, 
// all the internals get instrumented automatically.
#[loggable] 
mod m {
    pub fn g(param: i32) {
        for _ in 0..1000 {
            h();
            i();
        }
    }
    fn h() {}
    fn i() -> f32 {
        j();
        -1.23
    }
    fn j() {}
}

#[loggable] // The instrumenting macro for `f()`.
fn f() {}

my_func(); // Invocation of the function.
```

# What the FCL Is For
Some of the readers may wonder: "What such a functionality can be needed for?"  
Or someone can say: "Such a functionality is already implemented by the UNIX utility ???".

First of all, FCL demonstrates an example of Rust procedural macros that manipulate the source code. This is 
the information that I felt lack of after having read "[The Little Book of Rust Macros](https://lukaswirth.dev/tlborm/)".

Second, the UNIX utiltity ... requires the existence of that utility in the excution environment. 
It also requires an operating system. But the FCL let's the instrumented program to log its own 
function calls by itself, without using any utility and, even more, without using an operating system. 
The user's program instrumented with the FCL (or by example of FCL) can potentially run in bare metal environments
and log their functions over a hardware communication interface like SPI, UART, I2C, etc. (after the 
user's adjustments).

Third, the FCL can be used as a tool that facilitates the debugging or crash analysis. It can be tried in cases 
* when the bug does not show itself in the debugger,
* when the environment is not very friendly for attaching a debugger,
* when the debugger is not powerful enough or does not add clarity,
* when the debugger is a more resource-consuming tool, hard to set up, or otherwise less efficient,
* when the bug shows itself extremely rarely, e.g. once a month in a software running 24 hours a day, 
  or the consequence of the bug shows itself too late to break in the debugger,
  such that the only way to analyze the bug is by looking at the logs for the last few days or weeks.

For example, for the first time I implemented similar functionality in an environment that was simulating 
the hardware to run the firmware. Or in other words, the firmware was executed on a virtual hardware. 
There were issues attaching the debugger in that environemnt. So I added some hooks to the virtual hardware
that were catching the function call and return instructions and used the firmware debugging information to get 
the function names.  
Some time later when I worked with the Open On-Chip Debugger ([OpenOCD](https://openocd.org/)) I felt that 
such a tool would be useful for my work, but I didn't get a chance to develop the tool.  
Now with the help of FCL the developers can avoid the need for such tools if analyzing the code written in Rust.

Fourth, the FCL can be used for tests to make sure that certain functions have been invoked in a certain order, certain number of times, and, in some cases, with certain arguments and returned certain values.

For me personally FCL is a project where I practice my Rust programming skill after having studied some theory 
(the first Rust project of my own). 

<!-- Learning material to practice. I perceive it as a test covering the material that the young minds grasp in one semester.  
To get a record in my resume since (at the moment of writing) I'm unemployed, I live at the expense of my savings, 
and soon I will need to apply for jobs (after I study Rust to a level sufficient to pass (or ideally bypass) an interview ;-). -->
